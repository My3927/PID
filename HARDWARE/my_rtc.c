#include "my_rtc.h"
_calendar_obj calendar;//时钟结构体
static u8 count_addOneSecond = 0;

static void RTC_NVIC_Config(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQn;//RTC全局中断
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;//先占优先级1位,从优先级3位
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;//先占优先级0位,从优先级4位
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//使能该通道中断
    NVIC_Init(&NVIC_InitStructure);//根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器
}

//实时时钟配置
//初始化RTC时钟,同时检测时钟是否工作正常
//BKP->DR1用于保存是否第一次配置的设置
//返回0:正常
//其他:错误代码

bool My_RTC_Init(bool alarmEnable)
{
    //检查是不是第一次配置时钟
    u8 temp=0;
    if (BKP_ReadBackupRegister(BKP_DR1) != 0x5050)//从指定的后备寄存器中读出数据:读出了与写入的指定数据不相乎
    {
        RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);//使能PWR和BKP外设时钟
        PWR_BackupAccessCmd(ENABLE);//使能后备寄存器访问
        BKP_DeInit();//复位备份区域
        RCC_LSEConfig(RCC_LSE_ON);//设置外部低速晶振(LSE),使用外设低速晶振
        while ((RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET) && ++temp)
        {
            delay_ms(10);
        }//检查指定的RCC标志位设置与否,等待低速晶振就绪
        if(temp==0)
        {
            return false;//初始化时钟失败,晶振有问题
        }
        RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);//设置RTC时钟(RTCCLK),选择LSE作为RTC时钟    
        RCC_RTCCLKCmd(ENABLE);//使能RTC时钟
        RTC_WaitForLastTask();//等待最近一次对RTC寄存器的写操作完成
        RTC_WaitForSynchro();//等待RTC寄存器同步
        RTC_ITConfig(RTC_IT_SEC,ENABLE);//使能RTC秒中断
        //**All notes can be deleted and modified**//
        RTC_SetPrescaler(32767);//设置RTC预分频的值
        RTC_WaitForLastTask();//等待最近一次对RTC寄存器的写操作完成
        RTC_ExitConfigMode();//退出配置模式
        BKP_WriteBackupRegister(BKP_DR1, 0X5050);//向指定的后备寄存器中写入用户程序数据
    }
    else//系统继续计时
    {
        RTC_WaitForSynchro();//等待最近一次对RTC寄存器的写操作完成
        RTC_ITConfig(RTC_IT_SEC, ENABLE);//使能RTC秒中断
        RTC_ITConfig(RTC_IT_ALR, alarmEnable==true?ENABLE:DISABLE);//使能RTC闹钟中断
        RTC_WaitForLastTask();//等待最近一次对RTC寄存器的写操作完成
    }
    RTC_NVIC_Config();//RCT中断分组设置
    My_RTC_Update();//更新时间
    return true; //ok
}
//RTC时钟中断
//每秒触发一次  
//extern u16 tcnt; 
void RTC_IRQHandler(void)
{
    if (RTC_GetITStatus(RTC_IT_SEC) != RESET)//秒钟中断
    {
        My_RTC_Update();//更新时间
        //**All notes can be deleted and modified**//
    }
    if(RTC_GetITStatus(RTC_IT_ALR)!= RESET)//闹钟中断
    {
        RTC_ClearITPendingBit(RTC_IT_ALR);//清闹钟中断
    }
    RTC_ClearITPendingBit(RTC_IT_SEC|RTC_IT_OW);//清闹钟中断
    RTC_WaitForLastTask();
}
//判断是否是闰年函数
//月份   1  2  3  4  5  6  7  8  9  10 11 12
//闰年   31 29 31 30 31 30 31 31 30 31 30 31
//非闰年 31 28 31 30 31 30 31 31 30 31 30 31
//输入:年份
//输出:该年份是不是闰年.1,是.0,不是
bool Is_Leap_Year(u16 year)
{
    if(year%4==0) //必须能被4整除
    { 
        if(year%100==0) 
        { 
            if(year%400==0)
            {
                return true;//如果以00结尾,还要能被400整除
            }
            return false; 
        }
        return true;
    }
    return false;
}
//设置时钟
//把输入的时钟转换为秒钟
//以1970年1月1日为基准
//1970~2099年为合法年份
//返回值:0,成功;其他:错误代码.
//月份数据表
u8 const table_week[12]={0,3,3,6,1,4,6,2,5,0,3,5}; //月修正数据表
//平年的月份日期表
const u8 mon_table[12]={31,28,31,30,31,30,31,31,30,31,30,31};
/*************************************************************************
将日历结构体数据转换为32位整数，方便保存
**************************************************************************/
u32 My_RTC_CalendarToInteger(const _calendar_obj *cal)
{
    u16 t;
    u32 secCount=0;
    if(cal->year<1970||cal->year>2099)
    {
        return false;
    }
    for(t=1970;t<cal->year;t++)//把所有年份的秒钟相加
    {
        if(Is_Leap_Year(t))
        {
            secCount+=31622400;//闰年的秒钟数
        }
        else 
        {
            secCount+=31536000;//平年的秒钟数
        }
    }
    for(t=0;t<cal->month-1;t++)//把前面月份的秒钟数相加
    {
        secCount+=(u32)mon_table[t]*86400;//月份秒钟数相加
        //**All notes can be deleted and modified**//
    }
    secCount+=(u32)(cal->day-1)*86400;//把前面日期的秒钟数相加
    secCount+=(u32)cal->hour*3600;//小时秒钟数
    secCount+=(u32)cal->minute*60;//分钟秒钟数
    secCount+=cal->second;//最后的秒钟加上去
    return secCount;
}
/***************************************************************
将固定格式的字符串转换为日历结构体，如20200420173611为2020年4月20日17时36分11秒
***************************************************************/
void My_RTC_StringToCalendar(const char *str,_calendar_obj *cal)
{
    if(strlen(str)<14)
    {
        return;
    }
    cal->year = (str[0]-0x30)*1000 + (str[1]-0x30)*100 + (str[2]-0x30)*10 + (str[3]-0x30);//计算年份
    cal->month = (str[4]-0x30)*10 + (str[5]-0x30);//计算月份
    cal->day = (str[6]-0x30)*10 + (str[7]-0x30);//计算天
    cal->hour = (str[8]-0x30)*10 + (str[9]-0x30);//计算小时
    cal->minute = (str[10]-0x30)*10 + (str[11]-0x30);//计算分钟
    cal->second = (str[12]-0x30)*10 + (str[13]-0x30);//计算秒
}
/***************************************************************
将固定格式的字符串转换为整数方便保存，如20200420173611为2020年4月20日17时36分11秒
***************************************************************/
u32 My_RTC_StringToInteger(const char *str)
{
    _calendar_obj cal;
    My_RTC_StringToCalendar(str,&cal);
    return My_RTC_CalendarToInteger(&cal);//
}
/***************************************************************
将RTC的秒钟计数值转换为日历结构体
***************************************************************/
void My_RTC_IntegerToCalendar(u32 secondCount,_calendar_obj *cal)
{
    u32 temp=0;
    u16 temp1=1970;
    temp=secondCount/86400;//得到天数(秒钟数对应的)

    while(temp>=365)
    {
        if(Is_Leap_Year(temp1))//是闰年
        {
            if(temp>=366)
            {
                temp-=366;//闰年的秒钟数
            }
            else 
            {
                break;
            }
        }
        else 
        {
            temp-=365;//平年 
        }
        temp1++;  
    } 
    cal->year=temp1;//得到年份
    temp1=0;
    while(temp>=28)//超过了一个月
    {
        if(Is_Leap_Year(cal->year)&&temp1==1)//当年是不是闰年/2月份
        {
            if(temp>=29)
            {
                temp-=29;//闰年的秒钟数
            }
            else 
            {
                break; 
            }
        }
        else 
        {
            if(temp>=mon_table[temp1])
            {
                temp-=mon_table[temp1];//平年
            }
            else 
            {
                break;
            }
        }
        temp1++;
    }
    cal->month=temp1+1;//得到月份
    cal->day=temp+1;//得到日期 

    temp=secondCount%86400;//得到秒钟数
    cal->hour=temp/3600;//小时
    //**All notes can be deleted and modified**//
    cal->week=My_RTC_GetWeekday(cal->year,cal->month,cal->day);//获取星期
}
/***************************************************************
设置RTC时间
***************************************************************/
bool My_RTC_Set(u16 syear,u8 smon,u8 sday,u8 hour,u8 min,u8 sec)
{
    u32 secCount=0;
    _calendar_obj cal;
    cal.year = syear;
    cal.month = smon;
    cal.day = sday;
    cal.hour = hour;
    cal.minute = min;
    cal.second = sec;
    secCount = My_RTC_CalendarToInteger(&cal);
    My_RTC_SetCounter(secCount);
    return true;
}
void My_RTC_AddYear(int8 yearCount)
{
    u32 secCount=0;
    if(yearCount==0)
    {
        return;
    }
    calendar.year+=yearCount;
    secCount = My_RTC_CalendarToInteger(&calendar);
    My_RTC_SetCounter(secCount);
}
void My_RTC_AddMonth(int16 monthCount)
{
    u32 secCount=0;
    u32 monCount = (calendar.year<<3) + (calendar.year<<2) + calendar.month - 1;
    if(monthCount==0)
    {
        return;
    }
    monCount += monthCount;
    //**All notes can be deleted and modified**//
    secCount = My_RTC_CalendarToInteger(&calendar);
    My_RTC_SetCounter(secCount);
}
void My_RTC_AddDay(int16 dayCount)
{
    My_RTC_SetCounter(RTC_GetCounter()+dayCount*86400);//24*60*60=86400
}
void My_RTC_AddHour(int16 hourCount)
{
    My_RTC_SetCounter(RTC_GetCounter()+hourCount*3600);//60*60=3600
}
void My_RTC_AddMinute(int16 minuteCount)
{
    My_RTC_SetCounter(RTC_GetCounter()+minuteCount*60);//
}
void My_RTC_AddSecond(int16 secondCount)
{
    My_RTC_SetCounter(RTC_GetCounter()+secondCount);//
}
/***************************************************************
//使用年月日时分秒的字符串设置时间，如20200420173611为2020年4月20日17时36分11秒
***************************************************************/
bool My_RTC_SetStr(const char *str)
{
    _calendar_obj cal;
    My_RTC_StringToCalendar(str,&cal);
    return My_RTC_Set(cal.year,cal.month,cal.day,cal.hour,cal.minute,cal.second);//设置实时时钟时间
}
void My_RTC_SetCounter(u32 value)
{
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);//使能PWR和BKP外设时钟  
    PWR_BackupAccessCmd(ENABLE);//使能RTC和后备寄存器访问 
    if(count_addOneSecond==0)
    {
        count_addOneSecond=10;
        value += 1;
    }
    //**All notes can be deleted and modified**//
    RTC_SetCounter(value);//设置RTC计数器的值
    
    RTC_WaitForLastTask();//等待最近一次对RTC寄存器的写操作完成
    My_RTC_Update();
}
//得到当前的时间
//返回值:0,成功;其他:错误代码.
void My_RTC_Update(void)
{
    My_RTC_IntegerToCalendar(RTC_GetCounter(),&calendar);//获取星期
}
//获得现在是星期几
//功能描述:输入公历日期得到星期(只允许1901-2099年)
//输入参数：公历年月日 
//返回值：星期号
u8 My_RTC_GetWeekday(u16 year,u8 month,u8 day)
{
    u16 temp2;
    u8 yearH,yearL;

    yearH=year/100;
    yearL=year%100;
    // 如果为21世纪,年份数加100
    if (yearH>19)
    {
        yearL+=100;
    }
    // 所过闰年数只算1900年之后的
    temp2=yearL+yearL/4;
    temp2=temp2%7; 
    temp2=temp2+day+table_week[month-1];
    if (yearL%4==0&&month<3)
    {
        temp2--;
    }
    return(temp2%7);
}
//初始化闹钟
//以1970年1月1日为基准
//1970~2099年为合法年份
//syear,smon,sday,hour,min,sec：闹钟的年月日时分秒   
//返回值:0,成功;其他:错误代码.
u8 RTC_Alarm_Set(u16 syear,u8 smon,u8 sday,u8 hour,u8 min,u8 sec)
{
    u16 t;
    u32 seccount=0;
    if(syear<1970||syear>2099)return 1;
    for(t=1970;t<syear;t++)//把所有年份的秒钟相加
    {
        if(Is_Leap_Year(t))seccount+=31622400;//闰年的秒钟数
        else seccount+=31536000;//平年的秒钟数
    }
    smon-=1;
    for(t=0;t<smon;t++)//把前面月份的秒钟数相加
    {
        seccount+=(u32)mon_table[t]*86400;//月份秒钟数相加
        if(Is_Leap_Year(syear)&&t==1)seccount+=86400;//闰年2月份增加一天的秒钟数
    }
    seccount+=(u32)(sday-1)*86400;//把前面日期的秒钟数相加
    seccount+=(u32)hour*3600;//小时秒钟数
    seccount+=(u32)min*60;//分钟秒钟数
    seccount+=sec;//最后的秒钟加上去
    //**All notes can be deleted and modified**//
    PWR->CR|=1<<8;    //取消备份区写保护
    //上面三步是必须的!
    RTC->CRL|=1<<4;   //允许配置 
    RTC->ALRL=seccount&0xffff;
    RTC->ALRH=seccount>>16;
    RTC->CRL&=~(1<<4);//配置更新
    while(!(RTC->CRL&(1<<5)));//等待RTC寄存器操作完成  
    return 0;
}
u16 My_RTC_GetMilliSecond(void)
{
    return (32767-RTC_GetDivider())*1000/32767;
}
